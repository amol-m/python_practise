# -*- coding: utf-8 -*-
"""Untitled11.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1G5lxxmmw2X9Bbt1JBUmt5DokbTfCxk2S
"""

# upload file
# have removed spaces e.g "Reasearch & Development" to "RD"
import pandas as pd
import numpy as np
import seaborn as sns
from sklearn.impute import SimpleImputer
import matplotlib.pyplot as plt
from sklearn import preprocessing
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.preprocessing import OneHotEncoder

df_org = pd.read_csv("hr_modified_1.csv")
df = df_org

#replace space with nan
df = df.replace(r'^\s+$', np.nan, regex=True)

#df.info()
df[df.isna().any(axis=1)]

# df.info()
# listed are columns with nans

# BusinessTravel -char - 2 
# Department   - char   - 1
# EducationField  -char - 1

# DailyRate    - numeric   - 1            
# MonthlyIncome   -numeric  - 1      
# MonthlyRate     -numeric  - 1

# identifying BusinessTravel=='Travel_Rarely' and df.EducationField =='Medical' dataset
df_medical_travel_rarely = df[(df.BusinessTravel=='Travel_Rarely') & (df.EducationField =='Medical') ]
# replacing DailyRate with mean for dataset where BusinessTravel=='Travel_Rarely' and df.EducationField =='Medical'
df_daily_date = df_medical_travel_rarely['DailyRate']
df_df_daily_date = pd.DataFrame(df_daily_date)
df_df_daily_date['DailyRate'] = pd.to_numeric(df_df_daily_date['DailyRate'],errors = 'coerce')

# df_df_daily_date.mean()
df['DailyRate'] = df['DailyRate'].fillna(836.299694)

# df[df.isna().any(axis=1)]
#identifying Department for row 162 , Research And Development looks to be most occuring one
df_medical_travel_rarely.Department.value_counts(dropna=False)

df[df.isna().any(axis=1)]

# df[df.isna().any(axis=1)]
df['Department'] = df['Department'].fillna('RAD')

df.at[798, 'BusinessTravel'] ='Travel_Rarely'

df.at[516, 'BusinessTravel'] ='Travel_Rarely'

# checked for average of Attrition = Yes and Gender = Male and JobRole = Laboratory_Technician and MaritalStatus = Single
df.at[798, 'MonthlyIncome'] = 2978

# checked for average of Attrition = No and Gender = Female and JobRole = Research_Scientist and MaritalStatus = Married
df.at[516, 'MonthlyRate'] = 15533

df
df.at[1273, 'EducationField'] = 'LS'

df[df.isna().any(axis=1)]
# df_no_missing_values = df

df.info()

# columns listed below do not add any value on model.
# col = ['Attrition','EmployeeNumber','Over18']
col = ['EmployeeNumber','Over18']
X = df
for c in col:
  X = X.loc[:, X.columns != c]
y = df.Attrition

X['DailyRate'] = df['DailyRate'].astype(float)
X['MonthlyIncome'] = df['MonthlyIncome'].astype(float)
X['MonthlyRate'] = df['MonthlyRate'].astype(float)

X.info()

cat_cols=X.select_dtypes(include="object").columns

cat_cols_x = cat_cols.to_list()
cat_cols_x.remove('Attrition')
cat_cols_x

num_cols= X.select_dtypes(exclude="object").columns

num_cols

num_cols_x = num_cols.to_list()
no_need_to_scale =['Education','EnvironmentSatisfaction','JobInvolvement','JobLevel','JobSatisfaction','PercentSalaryHike','PerformanceRating','RelationshipSatisfaction','StockOptionLevel','WorkLifeBalance']
for c in no_need_to_scale:
  num_cols_x.remove(c)

from sklearn.preprocessing import StandardScaler
sc= StandardScaler()
X[num_cols_x]= sc.fit_transform(X[num_cols_x])

y.replace('Yes',1, inplace=True)
y.replace('No',0, inplace=True)

import seaborn as sns
sns.countplot (x=X.Department,hue=X.Attrition)

sns.countplot (x=X.BusinessTravel,hue=X.Attrition)

sns.countplot (x=X.Department,hue=X.Attrition)

sns.countplot (x=X.EducationField,hue=X.Attrition)

sns.countplot (x=X.Attrition )

"""Null accuracy = 1200/1400 = 85.7%"""

# tried One Hot encoding with sklearn however he issue is i could not get "Column Names" for newly derived columns.
# this causes issue for pairplots.

# from sklearn.preprocessing import OneHotEncoder
# from sklearn.compose import ColumnTransformer

# ct=ColumnTransformer(
# transformers=[('encoder',OneHotEncoder(sparse=False),[0])],remainder="passthrough")
# X_one=ct.fit_transform(X)
        
# pd.DataFrame(X_one)
# X_one
# ct.get_feature_names_out

# from sklearn.preprocessing import OneHotEncoder
# ohe = OneHotEncoder(sparse=False)
# X_ohe = ohe.fit_transform(X)
# ohe.get_feature_names_out()

X.drop(['Attrition'], axis=1, inplace=True)
dummies_df = pd.get_dummies(X, columns=cat_cols_x)
dummies_df.columns
dummies_df

from sklearn.model_selection import train_test_split
X_train,X_test,y_train,y_test = train_test_split(dummies_df,y,test_size=.25)

from sklearn.tree import DecisionTreeClassifier
clf = DecisionTreeClassifier()
clf.fit(X_train, y_train)
y_pred = clf.predict(X_test)

dummies_df.columns

from sklearn.metrics import accuracy_score
print(accuracy_score(y_test, y_pred))

from sklearn.metrics import confusion_matrix
cm = confusion_matrix(y_test,y_pred)
cm

# !pip install sklearn.externals.six 
# from sklearn.externals.six import StringIO  
# from IPython.display import Image  
# from sklearn.tree import export_graphviz
# import pydotplus

# dot_data = StringIO()
# export_graphviz(clf, out_file=dot_data,  
#                 filled=True, rounded=True,
#                 special_characters=True)

# graph = pydotplus.graph_from_dot_data(dot_data.getvalue())  
# Image(graph.create_png())

# https://machinelearningmastery.com/calculate-feature-importance-with-python/
from matplotlib import pyplot
# get importance
importance = clf.feature_importances_
# summarize feature importance
for i,v in enumerate(importance):
 print('Feature: %0d, Score: %.5f' % (i,v))
# plot feature importance
pyplot.bar([x for x in range(len(importance))], importance)
pyplot.show()

"""Following come out to be important features from CART
![image.png](data:image/png;base64,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)
"""

cat_cols_feat = dummies_df.select_dtypes(include="object").columns
num_cols_feat = dummies_df.select_dtypes(exclude="object").columns

from sklearn.pipeline import Pipeline
from sklearn.preprocessing import OneHotEncoder
from sklearn.linear_model import LogisticRegression
from sklearn.compose import ColumnTransformer

# Cat Tranformer 
categorical_tranformer= Pipeline(steps=[('ohe',OneHotEncoder())])

# Num tranfoemr
numerical_tranformer = Pipeline(steps=[('sc',StandardScaler())])

col_tranform= ColumnTransformer(transformers=[                                     
                                      ('cat_feat',categorical_tranformer,cat_cols_feat),\
                                     ('num_feat',numerical_tranformer,num_cols_feat),\
                                        ],
                                     remainder='passthrough')

X_trans = col_tranform.fit_transform(dummies_df)
type(X_trans)

my_pipeline= Pipeline(steps=[('first_pipe',col_tranform),('model',LogisticRegression())])
# X_train

my_pipeline.fit(X_train,y_train)

y_pred= my_pipeline.predict(X_test)

from sklearn.metrics import accuracy_score
pd.Series(accuracy_score(y_test,y_pred))

from sklearn import metrics
metrics.confusion_matrix(y_test,y_pred)

metrics.recall_score(y_test,y_pred)

from sklearn.ensemble import RandomForestClassifier
my_pipeline= Pipeline(steps=[('first_pipe',col_tranform),('model',RandomForestClassifier())])
my_pipeline.fit(X_train,y_train)

my_pipeline.fit(X_train,y_train)
y_pred= my_pipeline.predict(X_test)

from sklearn.metrics import accuracy_score
pd.Series(accuracy_score(y_test,y_pred))

from sklearn import metrics
metrics.confusion_matrix(y_test,y_pred)

metrics.precision_score(y_test,y_pred)

metrics.recall_score(y_test,y_pred)

metrics.f1_score(y_test,y_pred)

from sklearn.model_selection import GridSearchCV
from sklearn.ensemble import RandomForestClassifier

# # Define Parameters
# max_depth=[2, 8, 16]
# n_estimators = [64, 128, 256]
# param_grid = dict(max_depth=max_depth, n_estimators=n_estimators)

# # Build the grid search
# dfrst = RandomForestClassifier(n_estimators=n_estimators, max_depth=max_depth)
# grid = GridSearchCV(estimator=dfrst, param_grid=param_grid, cv = 5, scoring ='accuracy')
# grid_results = grid.fit(X_train, y_train)


# # Summarize the results in a readable format
# print("Best: {0}, using {1}".format(grid_results.cv_results_['accuracy'], grid_results.best_params_))
# results_df = pd.DataFrame(grid_results.cv_results_)
# results_df


# rf = RandomForestClassifier()

# # grid search cv
# grid_space={'max_depth':[3,5,10,None],
#               'n_estimators':[10,100,200],
#               'max_features':[1,3,5,7],
#               'min_samples_leaf':[1,2,3],
#               'min_samples_split':[1,2,3]
#            }

# grid = GridSearchCV(rf,param_grid=grid_space,cv=3,scoring='accuracy')
# model_grid = grid.fit(X_train,y_train)

# # grid search results
# print('Best grid search hyperparameters are: '+str(model_grid.best_params_))
# print('Best grid search score is: '+str(model_grid.best_score_))

!pip install sweetviz
import sweetviz

# my_report = sweetviz.compare([X, "Train"] "Attrition")
# my_report =sweetviz.analyze(source=df_org,target_feat='Attrition')

# my_report.show_html("Report.html")

"""** Gaussian naive bayes **
**this is the best fit of all**
"""

# X_train,X_test,y_train,y_test 
from sklearn.naive_bayes import GaussianNB
GNBclf = GaussianNB()
model = GNBclf.fit(X_train, y_train)
y_pred = model.predict(X_test)

metrics.recall_score(y_test,y_pred)

metrics.precision_score(y_test,y_pred)

metrics.f1_score(y_test,y_pred)

metrics.confusion_matrix(y_test,y_pred)

from sklearn.metrics  import confusion_matrix, ConfusionMatrixDisplay
metrics.confusion_matrix(y_test,y_pred)
# metrics.recall_score(y_test,y_pred)
cm = confusion_matrix(y_test, y_pred, labels=clf.classes_)
disp = ConfusionMatrixDisplay(confusion_matrix=cm,
                               display_labels=clf.classes_)
disp.plot()

from numpy import argmax
from sklearn.metrics import plot_roc_curve
roc = plot_roc_curve(model, X_test, y_test)

y_pred_prob = model.predict_proba(X_test)[:,1]

y_pred_prob

dummies_df.columns

"""Trying to identify if 'DailyRate','HourlyRate','MonthlyRate','MonthlyIncome' are co-related and any of these can be eliminated.
Checking this since Naive bayes treats each dimension independently and would work better if they are not related.
"""

dummies_df_corr = dummies_df[['DailyRate','HourlyRate','MonthlyRate','MonthlyIncome']]

correlations = dummies_df_corr.corr()
#sns.heatmap(correlations, xticklabels=correlations.columns, yticklabels=correlations.columns, annot=True)
sns.clustermap(correlations, xticklabels=correlations.columns, yticklabels=correlations.columns, annot=True)

"""Do not find strong corelation between these columns - 'DailyRate','HourlyRate','MonthlyRate','MonthlyIncome'.
no Pearson's correlation value is above 0.5
Trying to eliminate corelated columns for Naive bayes.
"""

dummies_df.info()

dummies_df_corr = dummies_df[['DailyRate','HourlyRate','MonthlyRate','MonthlyIncome']]

from scipy.stats import pearsonr
# calculate Pearson's correlation
# corr, _ = pearsonr(dummies_df_corr['DailyRate'], dummies_df_corr['HourlyRate'])
corr, _ = pearsonr(dummies_df_corr['DailyRate'], dummies_df_corr['HourlyRate'])
print('Pearsons correlation: %.3f' % corr)

param_grid_nb = {
    'var_smoothing': np.logspace(0,-9, num=100)
}

from sklearn.naive_bayes import GaussianNB
from sklearn.model_selection import GridSearchCV
nbModel_grid = GridSearchCV(estimator=GaussianNB(), param_grid=param_grid_nb, verbose=1, cv=10, n_jobs=-1)
nbModel_grid.fit(X_test, y_test)
print(nbModel_grid.best_estimator_)

y_pred = nbModel_grid.predict(X_test)

from sklearn.metrics import confusion_matrix
print(confusion_matrix(y_test, y_pred), ": is the confusion matrix")

from sklearn.metrics import f1_score
print(f1_score(y_test, y_pred), ": is the f1 score")

from sklearn.metrics import recall_score
print(recall_score(y_test, y_pred), ": is the recall score")

from sklearn.metrics  import confusion_matrix, ConfusionMatrixDisplay
metrics.confusion_matrix(y_test,y_pred)
# metrics.recall_score(y_test,y_pred)
cm = confusion_matrix(y_test, y_pred, labels=clf.classes_)
disp = ConfusionMatrixDisplay(confusion_matrix=cm,
                               display_labels=clf.classes_)
disp.plot()

from sklearn.metrics import f1_score
print(f1_score(y_test, y_pred), ": is the f1 score")

roc = plot_roc_curve(model, X_test, y_pred)

from numpy import mean
from sklearn.datasets import make_classification
from sklearn.model_selection import cross_val_score
from sklearn.model_selection import cross_val_predict
from sklearn.model_selection import RepeatedStratifiedKFold
from imblearn.pipeline import Pipeline
from imblearn.over_sampling import SMOTE

# define pipeline
steps = [('over', SMOTE()), ('model', GaussianNB())]
pipeline = Pipeline(steps=steps)
# evaluate pipeline
cv = RepeatedStratifiedKFold(n_splits=10, n_repeats=3, random_state=1)
# scores = cross_val_score(pipeline, X_train, y_train, scoring='roc_auc', cv=cv, n_jobs=-1)
# print('Mean ROC AUC: %.3f' % mean(scores))
# scores = cross_val_score(pipeline, X_train, y_train, scoring='recall', cv=cv, n_jobs=-1)
# print('Mean Recall: %.3f' % mean(scores))
my_pipeline= Pipeline(steps=[('over', SMOTE()), ('model', GaussianNB())])
my_pipeline.fit(X_train,y_train)
y_pred= my_pipeline.predict(X_test)
from sklearn.metrics import accuracy_score
# pd.Series(accuracy_score(y_test,y_pred))
from sklearn.metrics  import confusion_matrix, ConfusionMatrixDisplay
metrics.confusion_matrix(y_test,y_pred)
# metrics.recall_score(y_test,y_pred)
cm = confusion_matrix(y_test, y_pred, labels=clf.classes_)
disp = ConfusionMatrixDisplay(confusion_matrix=cm,
                               display_labels=clf.classes_)
disp.plot()

from sklearn.metrics import f1_score
print(f1_score(y_test, y_pred), ": is the f1 score")

from sklearn.metrics import recall_score
print(recall_score(y_test, y_pred), ": is the recall score")

"""Applying PCA - this is expected to give better results for Naive Bayes"""

# Set the n_components=3
from sklearn.decomposition import PCA

principal=PCA(n_components=18)
principal.fit(dummies_df)
Principal_components =principal.transform(dummies_df)

df_pca = pd.DataFrame(data = Principal_components, columns = ['PC 1', 'PC 2', 'PC 3','PC 4','PC 5','PC 6','PC 7', 'PC 8', 'PC 9', 'PC 10','PC 11','PC 12','PC 13','PC 14', 'PC 15','PC 16','PC 17','PC 18' ])

# Check the dimensions of data after PCA
print(df_pca.shape)

# check how much variance is explained by each principal component
print(principal.explained_variance_ratio_)

plt.plot(principal.explained_variance_ratio_.cumsum(), marker='p', color ='r', ls ='--')

df_pca

import numpy as np
import matplotlib
import matplotlib.pyplot as plt

PC_values = np.arange(principal.n_components_) + 1
plt.plot(PC_values, principal.explained_variance_ratio_, 'ro-', linewidth=2)
plt.title('Scree Plot')
plt.xlabel('Principal Component')
plt.ylabel('Proportion of Variance Explained')
plt.show()

X_train,X_test,y_train,y_test = train_test_split(df_pca,y,test_size=.25)

param_grid_nb = {
    'var_smoothing': np.logspace(0,-9, num=100)
}

from sklearn.naive_bayes import GaussianNB
from sklearn.model_selection import GridSearchCV
nbModel_grid = GridSearchCV(estimator=GaussianNB(), param_grid=param_grid_nb, verbose=1, cv=10, n_jobs=-1)
nbModel_grid.fit(X_train, y_train)
print(nbModel_grid.best_estimator_)

y_pred = nbModel_grid.predict(X_test)

from sklearn.naive_bayes import GaussianNB
GNBclf = GaussianNB()
model = GNBclf.fit(X_train, y_train)
y_pred = model.predict(X_test)

y_pred

from sklearn.metrics import confusion_matrix
print(confusion_matrix(y_test, y_pred), ": is the confusion matrix")

from sklearn.metrics import f1_score
print(f1_score(y_test, y_pred), ": is the f1 score")

from sklearn.metrics import recall_score
print(recall_score(y_test, y_pred), ": is the recall score")

from numpy import mean
from sklearn.datasets import make_classification
from sklearn.model_selection import cross_val_score
from sklearn.model_selection import cross_val_predict
from sklearn.model_selection import RepeatedStratifiedKFold
from imblearn.pipeline import Pipeline
from imblearn.over_sampling import SMOTE

# define pipeline
steps = [('over', SMOTE()), ('model', GaussianNB())]
pipeline = Pipeline(steps=steps)
# evaluate pipeline
cv = RepeatedStratifiedKFold(n_splits=10, n_repeats=3, random_state=1)
# scores = cross_val_score(pipeline, X_train, y_train, scoring='roc_auc', cv=cv, n_jobs=-1)
# print('Mean ROC AUC: %.3f' % mean(scores))
# scores = cross_val_score(pipeline, X_train, y_train, scoring='recall', cv=cv, n_jobs=-1)
# print('Mean Recall: %.3f' % mean(scores))
my_pipeline= Pipeline(steps=[('over', SMOTE()), ('model', GaussianNB())])
my_pipeline.fit(X_train,y_train)
y_pred= my_pipeline.predict(X_test)
from sklearn.metrics import accuracy_score
# pd.Series(accuracy_score(y_test,y_pred))
from sklearn.metrics  import confusion_matrix, ConfusionMatrixDisplay
metrics.confusion_matrix(y_test,y_pred)
# metrics.recall_score(y_test,y_pred)
cm = confusion_matrix(y_test, y_pred, labels=clf.classes_)
disp = ConfusionMatrixDisplay(confusion_matrix=cm,
                               display_labels=clf.classes_)
disp.plot()

from sklearn.metrics import f1_score
print(f1_score(y_test, y_pred), ": is the f1 score")
